;;;; 1st interpreter from Steele and Sussman "Art of the Interpreter"
;;;; Syntax adapted to CL conventions

(extern value1 (name slot))
(extern lookup (name env))
(extern lookup1 (name vars vals env))
(extern value (name env))

(defun bind (vars args env)
  (cond ((= (length vars) (length args))
	 (cons (cons vars args) env))
	(t (error "Vars and Args have different lengths when binding."))))

(defun value1 (name slot)
  (cond ((eq '&unbound slot) (error "Variable is unbound"))
	(t (car slot))))

(defun value (name env)
  (value1 name (lookup name env)))

(defun lookup1 (name vars vals env)
  (cond ((null vars) (lookup name (cdr env)))
	((eq (car vars) name) vals)
	(t (lookup1 name (cdr vars) (cdr vals) env))))

(defun lookup (name env)
  (cond ((null env) '&unbound)
	(t (lookup1 name (caar env) (cdar env) env))))

(externtc driver-loop1 (procedures form))
(externtc driver-loop (procedures hunoz))
(extern eval (exp env procedures))
(extern apply (fun args procedures))
(extern evcond (clauses env procedures))
(extern evlis (arglist env procedures))
(extern primop (fun))
(extern primop-apply (fun args))

(defun driver ()
  (driver-loop '(((car cdr eq atom cons)
		  &car &cdr &eq &atom &cons))
	       (repr 'lithp-ith-lithtening)))

(defuntc driver-loop (procedures hunoz)
  (driver-loop1 procedures (prog1_read)))

(defuntc driver-loop1 (procedures form)
  (cond ((atom form) (driver-loop procedures (eval form '() procedures)))
	((eq 'quit (car form)) nil)
	((eq 'defun (car form))
	 (driver-loop (bind (list (cadr form))
			    (list (list (caddr form) (cadddr form)))
			    procedures)
		      (print (cadr form))))
	((eq 'print-procs (car form))
	 (driver-loop procedures (print procedures)))
	(t (driver-loop procedures (print (eval form '() procedures))))))


(defun eval (exp env procedures)
  (cond ((atom exp) (cond ((eq 'nil exp) 'nil)
			  ((eq 't exp) 't)
			  ;; ((numberp exp) exp)
			  (t (value exp env))))
	((eq 'quote (car exp)) (cadr exp))
	((eq 'cond (car exp)) (evcond (cdr exp) env procedures))
	((eq 'if (car exp)) (eval (list 'cond
					(list (cadr exp) (caddr exp))
					(list 't (cadddr exp)))
				  env procedures))
	(t ;; (print exp)
	   (apply (value (car exp) procedures)
		  (evlis (cdr exp) env procedures)
		  procedures))))

(defun apply (fun args procedures)
  ;; (print fun)
  ;; (print args)
  (cond ((primop fun) (primop-apply fun args))
	(t (eval (cadr fun)
		 (bind (car fun) args '())
		 procedures))))

(defun evcond (clauses env procedures)
  (cond ((null clauses) (error "At least one clause of cond should match!"))
	((eval (caar clauses) env procedures)
	 (eval (cadar clauses) env procedures))
	(t (evcond (cdr clauses) env procedures))))

(defun evlis (arglist env procedures)
  ;; (print arglist)
  (cond ((null arglist) '())
	(t (cons (eval (car arglist) env procedures)
		 (evlis (cdr arglist) env procedures)))))

(defun primop (fun)
  (cond ((eq fun '&car) t)
	((eq fun '&cdr) t)
	((eq fun '&eq) t)
	((eq fun '&atom) t)
	((eq fun '&cons) t)
	(t nil)))

(defun primop-apply (fun args)
  (cond ((eq fun '&car) (car (car args)))
	((eq fun '&cdr) (cdr (car args)))
	((eq fun '&eq) (eq (car args) (cadr args)))
	((eq fun '&atom) (atom (car args)))
	((eq fun '&cons) (cons (car args) (cadr args)))
	(t (error "Got unknown primary operation"))))

